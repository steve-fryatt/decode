REM >!Master
REM
REM Copyright 1993-2014, Stephen Fryatt (info@stevefryatt.org.uk)
REM
REM This file is part of Master:
REM
REM   http://www.stevefryatt.org.uk/software/
REM
REM Licensed under the EUPL, Version 1.1 only (the "Licence");
REM You may not use this work except in compliance with the
REM Licence.
REM
REM You may obtain a copy of the Licence at:
REM
REM   http://joinup.ec.europa.eu/software/page/eupl
REM
REM Unless required by applicable law or agreed to in
REM writing, software distributed under the Licence is
REM distributed on an "AS IS" basis, WITHOUT WARRANTIES
REM OR CONDITIONS OF ANY KIND, either express or implied.
REM
REM See the Licence for the specific language governing
REM permissions and limitations under the Licence.

LIBRARY "BASIC:Icon"
LIBRARY "BASIC:Menu"
LIBRARY "BASIC:Message"
LIBRARY "BASIC:Resources"
LIBRARY "BASIC:Template"
LIBRARY "BASIC:Url"
LIBRARY "BASIC:WimpError"
LIBRARY "BASIC:WimpSprite"
LIBRARY "BASIC:Window"

PROCwimperror_initialise("Master", "!master")
ON ERROR result% = FNwimperror_program : END

REM These values get replaced by tokenize.

build_version$ = "1.10"
build_date$ = "01 Jul 2009"

PROCinitialise

ON ERROR Quit% = FNwimperror_program

WHILE NOT Quit%
	PROCpoll
ENDWHILE

SYS "Wimp_CloseDown"
END


REM Handle calls to Wimp_Poll and process the responses.
:
DEF PROCpoll
LOCAL reopen%, reason%

SYS "Wimp_Poll", &3C01, b% TO reason%

CASE reason% OF
	WHEN 2	: SYS "Wimp_OpenWindow",,b%
	WHEN 3	: SYS "Wimp_CloseWindow",,b%
	WHEN 6	: PROCmouse_click(b%!12, b%!16, b%!8)
	WHEN 7	: PROCplace_colour
	WHEN 9
 SYS "Wimp_GetPointerInfo",,q%
 reopen%=(q%!8 = 1)
 CASE !b% OF
  WHEN 1 : OSCLI("%Filer_Run <Master$Dir>.!Help")
  WHEN 2 : SolidDrags%=NOTSolidDrags%:PROCmenu_set_state(IconbarMenu%, 2, SolidDrags%, FALSE)
  WHEN 3 : Quit%=TRUE
 ENDCASE
 IF reopen% THEN PROCmenu_create(FNmenu_current_handle, 0, 0)
WHEN 17,18
 CASE b%!16 OF
  WHEN 0      : Quit%=TRUE
  WHEN &4E383 : PROCurl_bounce(b%)
 ENDCASE
WHEN 19 : IF b%!16 = &4AF80 THEN PROCurl_bounce(b%)
ENDCASE
ENDPROC
:
DEF PROCmouse_click(window%,icon%,button%)
CASE window% OF
  WHEN -2
    CASE button% OF
      WHEN 2 : PROCmenu_create_iconbar(IconbarMenu%, !b%)
      WHEN 1,4 : PROCwindow_open(MainWindow%)
      ENDCASE
  WHEN MainWindow%
    CASE button% OF
      WHEN 64 : PROCdrag_col(window%,icon%)
      WHEN 1,4
        CASE icon% OF
          WHEN 106 : IF DragsEnabled% THEN PROCscore_next
          WHEN 108 : PROCnew
          ENDCASE
      ENDCASE
  WHEN InfoWindow%
    IF button% = 4 AND icon% = 8 THEN
      PROCurl_launch(FNmessage_lookup("SupportURL"))
      PROCmenu_create(-1,0,0)
    ENDIF
  ENDCASE
ENDPROC





:
DEF PROCdrag_col(w%,i%)
IF (w% <> MainWindow%) OR (NOT DragsEnabled%) THEN ENDPROC
IF FNget_guess_peg_colour(i%) = -1 THEN ENDPROC

IF i% < 10 THEN
	PROCdrag(w%, i%)
	DragColour% = i%
	DragFrom%=-1
ENDIF

IF i% > 9 AND i% < 58 THEN
	PROCdrag(w%, i%)
	DragColour% = FNget_guess_peg_colour(i%)
	DragFrom% = i%
	IF DragFrom% > valid% AND SolidDrags% THEN
		PROCset_guess_peg_colour(DragFrom%, -1)
		IF DragFrom% - valid% < 5 AND DragFrom% - valid% > -1 THEN sequ%(DragFrom% - valid% - 1) = -1
	ENDIF
ENDIF
ENDPROC
:
DEF PROCplace_colour
icon% = FNdrag_end

IF icon% > valid% AND icon% < 58 THEN
	PROCset_guess_peg_colour(icon%, DragColour%)
	IF icon%-valid% < 5 AND icon%-valid% > -1 THEN sequ%(icon%-valid%-1) = DragColour%
ENDIF

IF DragFrom% > valid% AND DragFrom% <> icon% AND NOT SolidDrags% THEN
	PROCset_guess_peg_colour(DragFrom%, -1)
	IF DragFrom%-valid% < 5 AND DragFrom%-valid% > -1 THEN sequ%(DragFrom%-valid%-1) = -1
ENDIF
ENDPROC
:
DEF PROCdrag(whan%,icon%)
LOCAL ox%,oy%,x1%,y1%,x2%,y2%,sprite$
sprite$=$FNicon_indirection(whan%,icon%)
!q%=whan%
SYS "Wimp_GetWindowState",,q%
ox%=q%!4-q%!20
oy%=q%!16-q%!24
x1%=q%!4
y1%=q%!8
x2%=q%!12
y2%=q%!16
q%!4=icon%
SYS "Wimp_GetIconState",,q%
q%!4=5
q%!8=ox%+q%!8
q%!12=oy%+q%!12
q%!16=ox%+q%!16
q%!20=oy%+q%!20
q%!24=x1%
q%!28=y1%
q%!32=x2%
q%!36=y2%
IF DragASpriteStart%<>-1 AND SolidDrags% THEN
SYS "DragASprite_Start",%00100101,SpriteArea%,sprite$,q%+8,q%+24
ELSE
SYS "Wimp_DragBox",,q%
ENDIF
ENDPROC
:
DEF FNdrag_end
IF DragASpriteStop%<>-1 AND SolidDrags% THEN SYS "DragASprite_Stop"
SYS "Wimp_GetPointerInfo",,q%
=q%!16
:
DEF FNnew_target
LOCAL t%,i%,near%
valid%=9
CurrentLine%=1
PROCdisplay_message("Guess")
REPEAT
t%=RND(9999)
PROCscore(t%,t%,near%,i%)
UNTIL near%=0
=t%
:
DEF PROCscore_next
guess%=FNget_guess
IF guess%=-1 THEN PROCwimperror_report(FNmessage_lookup("NotComplete"), 1, %01, "") : ENDPROC
hits%=0 : near%=0
PROCscore(guess%,target%,near%,hits%)
PROCblacks(hits%,0,CurrentLine%)
PROCwhites(near%,hits%,CurrentLine%)
sequ%()=-1
valid%+=4
CurrentLine%+=1
IF CurrentLine%<=12 THEN PROCline(CurrentLine%)
IF hits%=4 THEN PROCwin
IF CurrentLine%=13 AND hits%<>4 THEN PROCend
ENDPROC
:
DEF PROCline(l%)
IF l%>1 THEN
PROCicon_set_colours(MainWindow%,(l%-1)+108,7,1)
ENDIF
PROCicon_set_colours(MainWindow%,l%+108,11,1)
ENDPROC
:
DEF FNget_guess
LOCAL s$,i%,fail%
fail%=FALSE
FOR i%=0 TO 3
IF sequ%(i%)<>-1 THEN
s$+=STR$(sequ%(i%))
ELSE
fail%=TRUE
ENDIF
NEXT i%
IF fail% THEN =-1
=VAL(s$)
:
DEF PROCscore(n%,t%,RETURN c%,RETURN p%)
LOCAL i%,b%
c%=0 : p%=0
FOR i%=1 TO 4
FOR b%=1 TO 4
IF FNin(n%,i%)=FNin(t%,b%) THEN
IF i%=b% THEN p%+=1 ELSE c%+=1
ENDIF
NEXT b%
NEXT i%
ENDPROC
:
DEF PROCblacks(n%,o%,l%)
LOCAL index%,plot%
IF n%=0 THEN ENDPROC
index%=58+((l%-1)*4)+o%
FOR plot%=index% TO index%+n%-1
	PROCset_score_peg_colour(plot%, 1)
NEXT plot%
ENDPROC
:
DEF PROCwhites(n%,o%,l%)
LOCAL index%,plot%
IF n%=0 THEN ENDPROC
index%=58+((l%-1)*4)+o%
FOR plot%=index% TO index%+n%-1
	PROCset_score_peg_colour(plot%, 0)
NEXT plot%
ENDPROC
:
DEF FNin(n%,p%)
LOCAL s$
s$=STR$(n%)
WHILE LENs$<4
s$="0"+s$
ENDWHILE
=VAL(MID$(s$,p%,1))
:
DEF PROCnew
LOCAL peg%
target%=FNnew_target
FOR peg%=10 TO 57
	PROCset_guess_peg_colour(peg%, -1)
NEXT peg%
FOR peg%=58 TO 105
	PROCset_score_peg_colour(peg%, -1)
NEXT peg%
FOR peg%=0 TO 9
	PROCset_guess_peg_colour(peg%, peg%)
NEXT peg%
sequ%()=-1
DragsEnabled%=TRUE
PROCline(1)
ENDPROC
:
DEF PROCwin
LOCAL i%
PROCdisplay_message("Correct")
PROCshow_sequence
FOR i%=109 TO 120
PROCicon_set_colours(MainWindow%,i%,7,1)
NEXT i%
PROCset_new_score(CurrentLine%-1)
VDU 7
DragsEnabled%=FALSE
ENDPROC
:
DEF PROCend
LOCAL i%
PROCdisplay_message("Slow")
PROCshow_sequence
FOR i%=109 TO 120
PROCicon_set_colours(MainWindow%,i%,7,1)
NEXT i%
PROCset_new_score(CurrentLine%-1)
VDU 7
DragsEnabled%=FALSE
ENDPROC
:
DEF PROCshow_sequence
LOCAL peg%
FOR peg%=0 TO 2
	PROCset_guess_peg_colour(peg%, -1)
NEXT peg%
FOR peg%=3 TO 6
	PROCset_guess_peg_colour(peg%, FNin(target%, peg% - 2))
NEXT peg%
FOR peg%=7 TO 9
	PROCset_guess_peg_colour(peg%, -1)
NEXT peg%
ENDPROC
:



REM Set the colour of a larger guessing peg.
REM
REM \param icon%		The icon in the window to set (0 to 57).
REM \param colour%		The peg "colour" (-1 for empty, else 0 to 9).
:
DEF PROCset_guess_peg_colour(icon%, colour%)
LOCAL sprite$

IF icon% < 0 OR icon% > 57 THEN ENDPROC
IF colour% = -1 THEN sprite$ = "ph" ELSE sprite$ = "p" + STR$(colour%)
PROCicon_set_indirected_text(MainWindow%, icon%, sprite$)
PROCicon_redraw(MainWindow%, icon%)
ENDPROC


REM Return the "colour" of a guess peg, given its icon number.
REM
REM \param icon%		The icon of interest (58 ro 105).
REM \return			The peg colour (0 to 9) or -1 for empty.
:
DEF FNget_guess_peg_colour(icon%)
LOCAL sprite$

IF icon% < 0 OR icon% >= 58 THEN =-1
sprite$ = $FNicon_indirection(MainWindow%, icon%)
IF LEFT$(sprite$, 1) <> "p" OR sprite$ = "ph" THEN =-1
=VAL(MID$(sprite$, 2))


REM Set the colour of a smaller scoring peg.
REM
REM \param icon%		The icon in the window to set (58 to 105).
REM \param colour%		The peg "colour" (-1 for empty, 0 for white,
REM				1 for black).
:
DEF PROCset_score_peg_colour(icon%, colour%)
LOCAL sprite$

IF icon% < 58 OR icon% > 105 THEN ENDPROC
CASE colour% OF
	WHEN 0		: sprite$ = "s0"
	WHEN 1		: sprite$ = "s1"
	OTHERWISE	: sprite$ = "sh"
ENDCASE
PROCicon_set_indirected_text(MainWindow%, icon%, sprite$)
PROCicon_redraw(MainWindow%, icon%)
ENDPROC


REM Display a message in the status field at the top of the window.
REM
REM \param token$		The message token for the message to display.
:
DEF PROCdisplay_message(token$)
PROCicon_set_indirected_text(MainWindow%, 107, FNmessage_lookup(token$))
PROCicon_redraw(MainWindow%, 107)
ENDPROC


REM Set a new score, updating the high score if that's beaten.
REM
REM \param new_score%		The new score to set.
:
DEF PROCset_new_score(new_score%)
LastScore% = new_score%
IF LastScore% < HighScore% THEN HighScore% = LastScore%
PROCicon_set_indirected_text(MainWindow%, 121, STR$(LastScore%))
PROCicon_set_indirected_text(MainWindow%, 123, STR$(HighScore%))
PROCicon_redraw(MainWindow%, 121)
PROCicon_redraw(MainWindow%, 123)
ENDPROC


REM Initialise ourselves, internally and with the Wimp.
:
DEF PROCinitialise
LOCAL resources$, task_name$, task_sprite$, indirected_data%, indirected_size%, ibar_icon%

REM Set up the quit flag and global data blocks.

Quit% = FALSE

DIM b% 5000, q% 255, a% 255

REM Locate the application resources.

resources$ = FNresources_find_territory_folder("<Master$Dir>.Resources")

REM Load the messages file.

PROCmessage_initialise(resources$ + "Messages")

task_name$ = FNmessage_lookup("TaskName")
task_sprite$ = FNmessage_lookup("TaskSpr")
PROCwimperror_initialise(task_name$, task_sprite$)

REM Initialise with the Wimp.

q%!0 = &4E383
q%!4 = &4AF80
q%!8 = 0

SYS "Wimp_Initialise", 310, &4B534154, task_name$, q%

REM Load the application sprites.

SpriteArea% = FNwimpsprite_load_user_sprites("<Master$Dir>.SpriteFile")

REM Load the window templates.

indirected_size% = 2048
DIM indirected_data% indirected_size%

PROCtemplate_open(resources$ + "Templates")
PROCtemplate_load("Board", b%, indirected_data%, indirected_size%, -1)
b%!64 = SpriteArea%
FOR i% = 0 TO 105
	b%!(88 + 32*i% + 24) = SpriteArea%
NEXT i%
SYS "Wimp_CreateWindow",,b% TO MainWindow%
PROCtemplate_load("ProgInfo", b%, indirected_data%, indirected_size%, -1)
SYS "Wimp_CreateWindow",,b% TO InfoWindow%
PROCtemplate_close

$FNicon_indirection(InfoWindow%, 4) = CHR$(169) + " Stephen Fryatt, 1993-" + MID$(build_date$, 8)
$FNicon_indirection(InfoWindow%, 6) = build_version$ + " (" + build_date$ + ")"

REM Initialise and load the menu templates.

PROCmenu_initialise

b%!0 = InfoWindow%
PROCmenu_load_templates(resources$ + "Menus", b%)
IconbarMenu% = b%!0



DIM sequ%(3)
sequ%()=-1
hits%=0
near%=0
target%=0
guess%=0
CurrentLine%=0
LastScore%=12
HighScore%=12
DragsEnabled%=TRUE
SolidDrags%=FALSE

REM Initialise the dragging system.

PROCdrag_init

IF DragASpriteStart% = -1 THEN
	PROCmenu_set_state(IconbarMenu%, 2, FALSE, TRUE)
ELSE
	PROCmenu_set_state(IconbarMenu%, 2, TRUE, FALSE)
	SolidDrags% = TRUE
ENDIF

PROCline(1)
target%=FNnew_target
PROCset_new_score(12)

ibar_icon% = FNicon_create_standard_bar(-1, task_sprite$)
ENDPROC


REM Initialise the solid dragging.
:
DEF PROCdrag_init
LOCAL cmos%

DragASpriteStart% = FNlookup_swi_number("DragASprite_Start")
DragASpriteStop% = FNlookup_swi_number("DragASprite_Stop")

SYS "OS_Byte", 161, 28 TO ,,cmos%
IF (cmos% AND 2) = 0 THEN
	DragASpriteStart% = -1
	DragASpriteStop% = -1
ENDIF
ENDPROC


REM Given a SWI name, look up its number.
REM
REM \param swi$			The name of the SWI to look up.
REM \return			The corresponding number, or -1 if not found.
:
DEF FNlookup_swi_number(swi$)
LOCAL swi%

SYS "XOS_SWINumberFromString",,swi$ TO swi% ;flag%
IF (flag% AND 1) = 1 THEN =-1
=swi%

